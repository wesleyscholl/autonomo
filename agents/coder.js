/**
 * ðŸ’» Coder Agent
 * Generates production-ready JavaScript code based on plans using Gemini
 */

const { GoogleGenerativeAI } = require('@google/generative-ai');

class CoderAgent {
  constructor() {
    this.genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.model = null;
  }

  async initialize() {
    this.model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
  }

  async generateCode(plan) {
    return await this.generateWithGemini(plan);
  }

  async generateWithGemini(plan) {
    const prompt = this.buildCodingPrompt(plan);
    
    const result = await this.model.generateContent(prompt);
    const response = await result.response;
    const code = response.text();

    return this.extractAndValidateCode(code, plan);
  }

  buildCodingPrompt(plan) {
    return `
Generate production-ready Node.js code for the following feature plan:

PLAN DETAILS:
${JSON.stringify(plan, null, 2)}

REQUIREMENTS:
1. Create a complete, self-contained JavaScript module
2. Follow Node.js best practices and modern ES6+ syntax
3. Include comprehensive error handling
4. Add detailed JSDoc comments
5. Implement proper input validation
6. Include usage examples in comments
7. Make it compatible with Express.js integration
8. Ensure thread safety and resource cleanup
9. Optimize for readability and maintainability

CODE STRUCTURE:
- Module should export an object with metadata and methods
- Include name, description, version, and capabilities
- Implement execute() method as main entry point
- Add health check and status methods
- Include proper logging integration

SAFETY CONSIDERATIONS:
- No filesystem access outside approved directories
- No network calls to untrusted sources
- Input sanitization and validation
- Resource limits and timeouts
- Graceful error handling

OUTPUT FORMAT:
\`\`\`javascript
// Complete working JavaScript module
\`\`\`

Generate clean, maintainable code that adds real value to the application.
`;
  }

  extractAndValidateCode(response, plan) {
    // Extract JavaScript code from markdown code blocks
    const codeBlocks = response.match(/```(?:javascript|js)?\n([\s\S]*?)\n```/g);
    
    if (!codeBlocks || codeBlocks.length === 0) {
      // If no code blocks found, try to extract everything between specific markers
      const jsMatch = response.match(/```javascript\n([\s\S]*)\n```/) || 
                     response.match(/```js\n([\s\S]*)\n```/) ||
                     response.match(/```\n([\s\S]*)\n```/);
      
      if (jsMatch) {
        return this.validateGeneratedCode(jsMatch[1], plan);
      }
      
      // Last resort: assume entire response is code
      return this.validateGeneratedCode(response, plan);
    }

    // Get the largest code block (main implementation)
    const mainCodeBlock = codeBlocks
      .map(block => block.replace(/```(?:javascript|js)?\n?|\n?```/g, ''))
      .sort((a, b) => b.length - a.length)[0];

    return this.validateGeneratedCode(mainCodeBlock, plan);
  }

  validateGeneratedCode(code, plan) {
    // Basic validation
    if (!code || code.trim().length < 10) {
      throw new Error('Generated code is too short or empty');
    }

    // Check for required exports
    if (!code.includes('module.exports') && !code.includes('exports.')) {
      code += '\n\nmodule.exports = { /* Add proper exports */ };';
    }

    // Add safety wrapper if not present
    if (!code.includes('try') && !code.includes('catch')) {
      code = this.wrapWithSafety(code, plan);
    }

    // Add metadata if not present
    if (!code.includes('name:') && !code.includes('"name"')) {
      code = this.addMetadata(code, plan);
    }

    return code;
  }

  wrapWithSafety(code, plan) {
    return `
/**
 * ${plan.title}
 * Generated by Autonomo Coder Agent
 * Plan ID: ${plan.id}
 */

const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.simple(),
  transports: [new winston.transports.Console()]
});

try {
  ${code}
} catch (error) {
  logger.error('Feature execution error:', error);
  throw error;
}
`;
  }

  addMetadata(code, plan) {
    const metadata = `
const featureMetadata = {
  id: '${plan.id}',
  name: '${plan.title}',
  description: '${plan.description}',
  category: '${plan.category}',
  version: '1.0.0',
  created: new Date('${plan.created}'),
  agent: 'coder'
};

`;
    return metadata + code;
  }

  async process(input, collaborationContext) {
    // For agent collaboration
    const plan = input.result || input;
    return await this.generateCode(plan);
  }
}

module.exports = CoderAgent;